<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Power Rankings Reveal â€” PA Milk Society</title>
  <link rel="stylesheet" href="../league.css" />
  <link rel="stylesheet" href="rankings.css" />
</head>
<body>
  <div class="ambient" aria-hidden="true"></div>

  <div class="reveal-wrap" role="region" aria-label="Power Rankings Reveal">
    <div class="reveal-header" role="banner">
      <div>
        <div class="reveal-title">PA Milk Society â€” Power Rankings Reveal</div>
        <div class="reveal-sub">12 â†’ 1 presentation â€¢ Use arrows or buttons to advance</div>
      </div>
    </div>

    <!-- slides container -->
    <main id="slides" aria-live="polite">

      <!-- COUNTDOWN (initial active) -->
      <section class="slide countdown active" data-index="countdown" id="countdownSlide" aria-label="Countdown to reveal">
        <div class="content" style="display:flex;align-items:center;justify-content:center;flex-direction:column;height:100%;text-align:center;">
          <div style="background:#000;color:#fff;width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:24px;border-radius:8px;">
            <div style="font-weight:900;font-size:20px;letter-spacing:1px;margin-bottom:18px"></div>
            <div style="font-weight:900;font-size:20px;letter-spacing:1px;margin-bottom:18px">2025 MIDSEASON REVEAL</div>
            <div id="countdown" style="font-weight:900;font-size:56px;letter-spacing:2px">00:00:00</div>

          </div>
        </div>
      </section>

      <!-- INTRO (hidden until countdown unlock or skip) -->
      <section class="slide intro" data-index="intro" id="introSlide" aria-label="Intro: Midseason Reveal">
        <div class="content intro">
          <div class="hero">
            <img src="/league/pics/league-banner.jpg" alt="League banner" onerror="this.src='/league/pics/group.jpg'">
          </div>
          <h1>Power Rankings â€” Midseason Reveal</h1>
          <p>Welcome to the 2025 midseason power rankings reveal. We'll count down from 12 to 1 with a page for each manager: team info, record, PF/PA, projected record, and a mid-season deep dive.</p>
          <div style="display:flex;gap:10px;justify-content:center;margin-top:12px">
            <button class="start-btn" id="introStartBtn" disabled>Start Reveal</button>
            <button class="small-btn" id="skipIntro">Skip Intro</button>
          </div>
        </div>
      </section>

      <!-- Ranking slides generated by JS (will be inserted here) -->

      <!-- Total rankings (inserted by JS) -->

      <!-- Final slide placeholder (standings withheld per request) -->
      <section class="slide final" data-index="999" aria-label="Final slide">
        <div class="content" style="text-align:center;padding:18px;color:var(--text)">
          <h2>Thanks for watching the reveal</h2>
          <p style="color:var(--muted)">Full standings and power rankings are kept on the main site â€” you can view them anytime. Use the buttons below to replay or export votes.</p>
          <div style="display:flex;gap:10px;justify-content:center;margin-top:14px">
            <button class="start-btn" id="replayBtn">Replay</button>
            <button class="small-btn" id="exportVotes">Export Votes</button>
          </div>
        </div>
      </section>

    </main>

    <!-- controls -->
    <div class="controls" aria-hidden="false">
      <div class="nav-left">
        <button class="small-btn" id="prevBtn">â—€ Prev</button>
      </div>

      <div style="display:flex;align-items:center;gap:8px;flex:1">
        <div class="progress" aria-hidden="true"><i id="progressBar" style="width:0%"></i></div>
        <div style="color:var(--muted);font-weight:800" id="slideLabel">Countdown</div>
      </div>

      <div class="nav-right">
        <button class="small-btn" id="nextBtn">Next â–¶</button>
      </div>
    </div>

    <!-- decorative/confetti canvas -->
    <canvas id="confetti" style="position:absolute;pointer-events:none;inset:0;z-index:9999"></canvas>
  </div>

  <script type="module">
/* ========= Firebase init (unchanged) ========= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app.js";
import { getFirestore, doc, getDoc, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyAUk7lfFezJ-pL_-MaDSIoL5RzogPnJw4c",
  authDomain: "ffootball-1ffa4.firebaseapp.com",
  projectId: "ffootball-1ffa4",
  storageBucket: "ffootball-1ffa4.appspot.com",
  messagingSenderId: "214820317243",
  appId: "1:214820317243:web:00907255d3ee230f21541e",
  measurementId: "G-H9LQY4GWSN"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ==========================
   CONFIG: one-off target time
   Set the target to your desired New York (Eastern) time.
   Example below sets: 2025-10-22 at 19:30 (7:30 PM Eastern)
   Edit these values to change when the countdown ends/unlocks.
   ========================== */
const TARGET_YEAR = 2025;
const TARGET_MONTH = 10; // 1-12
const TARGET_DAY = 22;   // day of month
const TARGET_HOUR24 = 24; // +5 hours
const TARGET_MINUTE = 10; // minute (30 = :30)

/* ---------- robust teams.json loader (unchanged) ---------- */
/* ---------- robust teams.json loader (unchanged) ---------- */
async function loadTeams(){
  const tries = ['teams.json','./teams.json','../rankings/teams.json','/rankings/teams.json','/League/rankings/teams.json'];
  let json = null;
  for(const p of tries){
    try{
      const res = await fetch(p, {cache: "no-store"});
      if(!res.ok) continue;
      json = await res.json(); break;
    }catch(err){ continue; }
  }
  if(!json){
    return [
      { rank:12,team:'Tequila Sunrise',manager:'Connie',record:'2-5',pf:693.76,pa:865.2,projected:'2-12',playoff:2,image:'/assets/logos/tequila.png',summary:'Fallback placeholder.'},
      { rank:11,team:'The GLIZZYS',manager:'Luke',record:'2-5',pf:682.78,pa:803.7,projected:'4-10',playoff:4,image:'/assets/logos/theglizzys.png',summary:'Fallback placeholder.'}
    ];
  }
  let teams = Array.isArray(json) ? json : (json.teams || []);
  teams = teams.map((t,i)=>{
    const teamName = t.team ?? t.name ?? '';
    const wins = t.wins ?? t.w ?? null;
    const losses = t.losses ?? t.l ?? null;

    // robust pf/pa detection with common variations
    const pf = (t.pf ?? t.PF ?? t.pointsFor ?? t.points_for ?? t.pointsfor ?? t.pts_for) ?? null;
    const pa = (t.pa ?? t.PA ?? t.pointsAgainst ?? t.points_against ?? t.pointsagainst ?? t.pts_against) ?? null;

    return {
      rank: Number(t.rank ?? t.position ?? (i+1)) || (i+1),
      team: teamName,
      manager: t.manager ?? '',
      wins, losses,
      record: t.record ?? ((wins!==null && losses!==null) ? `${wins}-${losses}` : (t.record_str ?? '')),
      streak: t.streak ?? '',
      projected: t.projected ?? t.projected_record ?? t.projectedRecord ?? '',
      playoff: t.playoff ?? t.playoff_chance ?? t.playoffPct ?? 0,
      pf,               // points for
      pa,               // points against
      image: t.image ?? `/assets/logos/${slugify(teamName)}.png`,
      summary: t.summary ?? (t.note ?? '')
    };
  });
  const seen = new Set();
  teams.forEach((t,i)=>{ if(!t.rank || seen.has(t.rank)) t.rank = i+1; seen.add(t.rank); });
  return teams;
}

/* ---------- helper slugify ---------- */
function slugify(name){
  return (name||'').toString().toLowerCase().replace(/[^a-z0-9]+/g,'').replace(/\s+/g,'');
}

/* ---------- slide builder (async) ---------- */
async function createRankingSlides(){
  const teams = await loadTeams();
  if(!teams || teams.length===0){
    const container = document.getElementById('slides');
    const err = document.createElement('div');
    err.style.padding = '20px'; err.style.color = 'salmon';
    err.textContent = 'Error: teams.json could not be loaded or is empty â€” check browser console and file path.';
    container.appendChild(err); return;
  }

  // sort descending by rank so UI goes 12 -> 1
  teams.sort((a,b)=>b.rank - a.rank);

  const container = document.getElementById('slides');
  const final = document.querySelector('.slide.final');

  // remove previously injected ranking/total slides (but keep countdown & intro & final)
  Array.from(container.querySelectorAll('.slide')).forEach(s=>{
    if(!s.classList.contains('countdown') && !s.classList.contains('intro') && !s.classList.contains('final')) s.remove();
  });

  teams.forEach(t=>{
    const idx = t.rank;
    const slide = document.createElement('section');
    slide.className = 'slide';
    slide.dataset.index = idx;

    const imagePath = t.image || `/assets/logos/${slugify(t.team)}.png`;
    const medal = idx===1? 'ðŸ¥‡' : (idx===2? 'ðŸ¥ˆ' : (idx===3? 'ðŸ¥‰': ''));
    const medalClass = idx===1? 'first' : (idx===2? 'second' : (idx===3? 'third':''));

    slide.innerHTML = `
      <div class="content">
        <div class="rank-header" style="display:flex;align-items:center;gap:12px;">
          <div class="rank-badge">#${idx}</div>
          <div class="title-wrap" style="flex:1;min-width:0">
            <div class="team-name">${t.team}</div>
            <div class="manager" style="font-size:12px;color:var(--muted);margin-top:4px">${t.manager}</div>
          </div>
          <div class="team-logo-icon" aria-hidden="true"><img src="${imagePath}" alt="${t.team}" onerror="this.src='/league/pics/players.png'"></div>
        </div>

        ${medal ? `<div style="margin-top:12px"><div class="podium-wrap" style="justify-content:flex-start"><div class="pod ${medalClass}" style="display:inline-block;margin-left:0"><div class="medal">${medal}</div><div style="font-weight:900;margin-top:6px">${t.team}</div><div style="font-size:13px;color:#07120a;opacity:.9">#${idx}</div></div></div></div>` : ''}

        <div style="display:grid;grid-template-columns:56px 1fr;gap:12px;margin-top:12px;align-items:start">
          <div class="rank-photo"><img src="${imagePath}" alt="${t.team}" onerror="this.src='/league/pics/players.png'"></div>

          <div class="rank-body">
            <div class="rank-top" style="display:flex;justify-content:space-between;gap:12px;align-items:flex-start">
              <div style="min-width:0">
                <div style="display:flex;gap:8px;flex-wrap:nowrap;align-items:center">
                  <div class="meta" style="font-weight:800">Record: ${t.record}</div>
                  <div class="meta">PF: ${t.pf ?? '-'}</div>
                  <div class="meta">PA: ${t.pa ?? '-'}</div>
                </div>
              </div>

              <div style="text-align:right;min-width:0">
                <div style="font-weight:900;font-size:14px;margin-bottom:6px">Mid-season summary</div>
                <div class="projected" style="font-size:13px">Projected final: ${t.projected ?? '-'}</div>
              </div>
            </div>

            <div class="summary" style="margin-top:10px">${t.summary ?? ''}</div>

            <div class="vote-row" style="display:flex;gap:8px;margin-top:12px;align-items:center">
              <button class="vote-btn small-btn" data-vote="higher">Higher â–²</button>
              <button class="vote-btn small-btn" data-vote="lower">Lower â–¼</button>
              <div class="vote-count" style="margin-left:8px" id="voteDisplay_${idx}">0 â†‘ 0 â†“</div>
            </div>
          </div>
        </div>
      </div>
    `;
    container.insertBefore(slide, final);
  });

  // total slide (compact)
  const totalSlide = document.createElement('section');
  totalSlide.className = 'slide';
  totalSlide.dataset.index = 'total';
  const rows = teams.slice().sort((a,b)=>a.rank-b.rank).map(r=>{
    const logo = r.image || `/assets/logos/${slugify(r.team)}.png`;
    return `<tr><td class="logo-cell"><img src="${logo}" onerror="this.src='/league/pics/players.png'"></td><td style="min-width:140px"><strong>#${r.rank} ${r.team}</strong><div style="color:var(--muted);font-size:12px">${r.record}</div></td><td>${r.projected}</td><td>${r.playoff}%</td></tr>`;
  }).join('');
  totalSlide.innerHTML = `
    <div class="content" style="width:100%;padding:8px;color:var(--text)">
      <h2 style="margin:0 0 8px;font-size:16px">Total Power Rankings â€” Summary</h2>
      <p style="color:var(--muted);margin:0 0 10px;font-size:13px">Snapshot â€” compact view for mobile.</p>
      <div style="overflow:hidden">
        <table class="total-table" style="width:100%;font-size:13px;table-layout:fixed">
          <thead><tr><th style="width:44px"></th><th>Team / Record</th><th style="width:80px">Projected</th><th style="width:80px">Playoff</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>
      </div>
      <div style="margin-top:8px;display:flex;gap:8px;justify-content:center">
        <button class="small-btn" id="exportCSV">Export CSV</button>
        <button class="small-btn" id="backToStart">Back to Intro</button>
      </div>
    </div>
  `;
  container.insertBefore(totalSlide, final);

  initVotesDisplays();
}

/* ---------- voting functions ---------- */
async function fetchAndShowVotes(idx){
  try{
    const docRef = doc(db,'rankVotes','rank_'+idx);
    const snap = await getDoc(docRef);
    const data = snap.exists() ? snap.data() : {higher:0,lower:0};
    const higher = data.higher||0, lower = data.lower||0;
    const el = document.getElementById('voteDisplay_'+idx);
    if(el) el.textContent = `${higher} â†‘ ${lower} â†“`;
  }catch(err){ console.error('fetch votes',err); }
}

async function castVote(idx, type){
  try{
    const docRef = doc(db,'rankVotes','rank_'+idx);
    await runTransaction(db, async (tx) => {
      const snap = await tx.get(docRef);
      if(!snap.exists()){
        tx.set(docRef, { higher: type==='higher'?1:0, lower: type==='lower'?1:0, updatedAt: serverTimestamp() });
      } else {
        const data = snap.data(); const incH = type==='higher'?1:0; const incL = type==='lower'?1:0;
        tx.update(docRef, { higher: (data.higher||0) + incH, lower: (data.lower||0) + incL, updatedAt: serverTimestamp() });
      }
    });
    fetchAndShowVotes(idx);
  }catch(err){ console.error('cast vote',err); }
}

/* ---------- UI navigation & helpers ---------- */
function allSlides(){ return Array.from(document.querySelectorAll('.slide')); }
let current = 0;

function updateSlides(){
  const slides = allSlides();
  slides.forEach((s,i)=>{ s.classList.remove('active'); s.style.zIndex=1; });
  if(current < 0) current = 0; if(current > slides.length-1) current = slides.length-1;
  const active = slides[current];
  if(active){ active.classList.add('active'); active.style.zIndex=20; }
  const label = active.classList.contains('countdown') ? 'Countdown' : (active.classList.contains('intro') ? 'Intro' : (active.classList.contains('final') ? 'Final' : (active.dataset.index==='total' ? 'Total Rankings' : `Rank ${active.dataset.index}`)));
  const slideLabelEl = document.getElementById('slideLabel');
  if(slideLabelEl) slideLabelEl.textContent = label;
  const progressBar = document.getElementById('progressBar');
  if(progressBar){
    const prog = Math.round((current/(slides.length-1))*100);
    progressBar.style.width = prog+'%';
  }
  // fetch votes for active numeric slides
  if(active && !isNaN(Number(active.dataset.index))) fetchAndShowVotes(active.dataset.index);
  // confetti for top 3 when shown
  if(active && ['1','2','3'].includes(String(active.dataset.index))) fireConfetti(24);
}

function goToSlideIndexOf(selector){
  const slides = allSlides();
  const idx = slides.findIndex(s => s.matches(selector));
  if(idx >= 0){ current = idx; updateSlides(); window.scrollTo({top:0,behavior:'smooth'}); }
}

function nextSlide(){ if(current < allSlides().length-1){ current++; updateSlides(); window.scrollTo({top:0,behavior:'smooth'}); } }
function prevSlide(){ if(current > 0){ current--; updateSlides(); window.scrollTo({top:0,behavior:'smooth'}); } }

/* attach basic handlers (buttons exist in markup) */
const nxtBtn = document.getElementById('nextBtn');
const prvBtn = document.getElementById('prevBtn');
if(nxtBtn) nxtBtn.addEventListener('click', nextSlide);
if(prvBtn) prvBtn.addEventListener('click', prevSlide);
const skipIntroBtn = document.getElementById('skipIntro');
if(skipIntroBtn) skipIntroBtn.addEventListener('click', ()=>{ goToSlideIndexOf('.slide[data-index="intro"]'); });
const replayBtn = document.getElementById('replayBtn');
if(replayBtn) replayBtn.addEventListener('click', ()=>{ goToSlideIndexOf('.slide[data-index="intro"]'); });

document.addEventListener('keydown', (e)=>{ if(e.key==='ArrowRight') nextSlide(); if(e.key==='ArrowLeft') prevSlide(); } );
let touchStartX=0, touchEndX=0;
document.addEventListener('touchstart',(e)=>{ touchStartX = e.changedTouches[0].screenX; });
document.addEventListener('touchend',(e)=>{ touchEndX = e.changedTouches[0].screenX; if(touchEndX - touchStartX > 40) prevSlide(); if(touchStartX - touchEndX > 40) nextSlide(); });

document.addEventListener('click',(e)=>{
  const btn = e.target.closest('.vote-btn'); if(!btn) return;
  const slide = btn.closest('.slide'); if(!slide) return;
  const idx = slide.dataset.index; const vote = btn.dataset.vote;
  btn.animate([{transform:'translateY(-6px)'},{transform:'translateY(0)'}],{duration:220});
  castVote(idx, vote);
});

/* export and CSV handlers */
const exportVotesBtn = document.getElementById('exportVotes');
if(exportVotesBtn) exportVotesBtn.addEventListener('click', async ()=>{
  try{
    const out = {};
    for(let i=1;i<=12;i++){ const snap = await getDoc(doc(db,'rankVotes','rank_'+i)); out[i] = snap.exists() ? snap.data() : {higher:0,lower:0}; }
    const blob = new Blob([JSON.stringify(out,null,2)],{type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='rank_votes.json'; a.click(); URL.revokeObjectURL(url);
  }catch(err){ console.error('export',err); }
});

document.addEventListener('click',(e)=>{
  if(e.target.id==='exportCSV'){
    (async ()=>{
      const teams = await loadTeams();
      const rows = teams.slice().sort((a,b)=>a.rank-b.rank).map(r=>`${r.rank},"${r.team}",${r.record},${r.projected},${r.playoff}`);
      const csv = 'Rank,Team,Record,Projected,Playoff\n' + rows.join('\n');
      const blob = new Blob([csv],{type:'text/csv'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'power_rankings.csv'; a.click(); URL.revokeObjectURL(url);
    })();
  }
  if(e.target.id==='backToStart') goToSlideIndexOf('.slide[data-index="intro"]');
});

/* vote displays */
async function initVotesDisplays(){
  for(let i=1;i<=12;i++){ const el = document.getElementById('voteDisplay_'+i); if(el) fetchAndShowVotes(i); }
}

/* ---------- confetti ---------- */
const confettiCanvas = document.getElementById('confetti');
const ctx = confettiCanvas ? confettiCanvas.getContext('2d') : null;
function fitCanvas(){ if(confettiCanvas){ confettiCanvas.width = window.innerWidth; confettiCanvas.height = window.innerHeight; } }
window.addEventListener('resize', fitCanvas); fitCanvas();
function fireConfetti(pieces=20){
  if(!ctx || !confettiCanvas) return;
  const confetti = [];
  for(let i=0;i<pieces;i++){
    confetti.push({
      x: Math.random()*confettiCanvas.width,
      y: Math.random()*confettiCanvas.height*0.25 + 40,
      w: 6 + Math.random()*8, h: 8 + Math.random()*8,
      vx: -6 + Math.random()*12, vy: Math.random()*4 + 2,
      rot: Math.random()*360,
      color: `hsl(${Math.random()*60+180},70%,60%)`
    });
  }
  let t=0;
  function draw(){
    ctx.clearRect(0,0,confettiCanvas.width,confettiCanvas.height);
    for(const c of confetti){
      c.x += c.vx; c.y += c.vy; c.vy += 0.2; c.rot += c.vx*0.3;
      ctx.save(); ctx.translate(c.x,c.y); ctx.rotate(c.rot*Math.PI/180);
      ctx.fillStyle = c.color; ctx.fillRect(-c.w/2,-c.h/2,c.w,c.h); ctx.restore();
    }
    t++;
    if(t<120) requestAnimationFrame(draw); else ctx.clearRect(0,0,confettiCanvas.width,confettiCanvas.height);
  }
  draw();
}

/* ==========================
   ONE-OFF COUNTDOWN (NEW)
   - Locks UI until target New York datetime
   - When target reached: remove countdown slide, unlock UI, show Intro
   ========================== */
(function(){
  const revealWrap = document.querySelector('.reveal-wrap');
  const countdownEl = document.getElementById('countdown');
  const countdownNote = document.getElementById('countdown-note');

  // convert a NY wall-clock (y,m,d,h,mm,ss) into UTC ms reliably using Intl
  function nyWallTimeToUtcMs(year, month, day, hour, minute = 0, second = 0){
    // create a formatter to get wall-time parts in NY
    // We'll construct a string in NY local and then compute its UTC ms by using the known offset at that instant.
    // Step: get the offset hours for an instant near the requested date by asking Intl.
    const naiveUtc = Date.UTC(year, month - 1, day, hour, minute, second);
    // Determine NY offset at that naive instant
    const instant = new Date(naiveUtc);
    let offsetHours = 0;
    try{
      const s = instant.toLocaleString('en-US', { timeZone: 'America/New_York', timeZoneName: 'short' });
      const m = s.match(/GMT([+-]\d{1,2})/);
      if(m && m[1]) offsetHours = Number(m[1]);
      else {
        // fallback
        const ny = new Date(instant.toLocaleString('en-US', { timeZone: 'America/New_York' }));
        offsetHours = (ny.getTime() - instant.getTime())/3600000;
      }
    }catch(e){
      const ny = new Date(instant.toLocaleString('en-US', { timeZone: 'America/New_York' }));
      offsetHours = (ny.getTime() - instant.getTime())/3600000;
    }
    // true UTC ms = naiveUtc - offsetHours*3600000
    return naiveUtc - (offsetHours * 3600000);
  }

  // build the target UTC ms from config constants
  const targetUtcMs = nyWallTimeToUtcMs(TARGET_YEAR, TARGET_MONTH, TARGET_DAY, TARGET_HOUR24, TARGET_MINUTE, 0);

  function msToHHMMSS(ms){
    if(ms < 0) ms = 0;
    const s = Math.floor(ms/1000);
    const hh = String(Math.floor(s/3600)).padStart(2,'0');
    const mm = String(Math.floor((s%3600)/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    return `${hh}:${mm}:${ss}`;
  }

  // lock UI: add .locked which you already added CSS for earlier
  function lockUI(){ if(!revealWrap.classList.contains('locked')) revealWrap.classList.add('locked'); }
  function unlockUI(){ revealWrap.classList.remove('locked'); }

  // Ensure the countdown slide is the only visible slide while locked
  function showOnlyCountdown(){
    // make countdown slide current visually
    const slides = allSlides();
    slides.forEach(s => { s.classList.remove('active'); s.style.zIndex = 1; });
    const cd = document.querySelector('.slide.countdown');
    if(cd){ cd.classList.add('active'); cd.style.zIndex = 50; }
  }

  // Remove countdown slide from DOM (called once when unlocking)
  function removeCountdownSlide(){
    const cd = document.querySelector('.slide.countdown');
    if(cd && cd.parentElement) cd.parentElement.removeChild(cd);
  }

  // When unlocked: remove countdown slide and show intro slide
  function onUnlocked(){
    // remove the countdown slide so reopening the page won't show it
    removeCountdownSlide();
    // unlock UI (removes reveal-wrap.locked which restores header/controls)
    unlockUI();
    // navigate to intro slide
    const slides = allSlides();
    const introIndex = slides.findIndex(s => s.classList.contains('intro'));
    if(introIndex >= 0){
      current = introIndex;
      updateSlides();
    } else {
      // fallback: first non-final slide
      const idx = slides.findIndex(s => !s.classList.contains('final'));
      if(idx >=0){ current = idx; updateSlides(); }
    }
  }

  // tick loop
  function tick(){
    const now = Date.now();
    const remaining = targetUtcMs - now;
    if(remaining > 0){
      // still locked
      lockUI();
      // show only countdown
      showOnlyCountdown();
      if(countdownEl) countdownEl.textContent = msToHHMMSS(remaining);
      if(countdownNote) countdownNote.textContent = `Unlocks at ${String(TARGET_HOUR24).padStart(2,'0')}:${String(TARGET_MINUTE).padStart(2,'0')} Eastern on ${TARGET_MONTH}/${TARGET_DAY}/${TARGET_YEAR}`;
    } else {
      // unlocked â€” call once, stop the timer
      clearInterval(timer);
      if(countdownEl) countdownEl.textContent = "00:00:00";
      if(countdownNote) countdownNote.textContent = "Unlocked â€” showing intro";
      onUnlocked();
    }
  }

  // Prevent navigation while locked: wrap next/prev to check .locked
  const origNext = window.nextSlide;
  const origPrev = window.prevSlide;
  window.nextSlide = function(){ if(revealWrap.classList.contains('locked')) return; if(typeof origNext === 'function') return origNext(); };
  window.prevSlide = function(){ if(revealWrap.classList.contains('locked')) return; if(typeof origPrev === 'function') return origPrev(); };

  // prevent keyboard navigation when locked (capturing)
  document.addEventListener('keydown', (e)=>{ if(revealWrap.classList.contains('locked')) { if(e.key==='ArrowRight' || e.key==='ArrowLeft') { e.stopImmediatePropagation(); e.preventDefault(); } } }, {capture:true});

  // start ticking after slides are created
  const timer = setInterval(tick, 1000);
  tick(); // initial call
})();
  
/* ---------- init (build slides then start UI) ---------- */
(async function init(){
  await createRankingSlides();
  // after building, choose the initial visible slide:
  // if countdown slide exists and is still present, keep it active (script above will manage locked state)
  const slides = allSlides();
  const countdownIndex = slides.findIndex(s => s.classList.contains('countdown'));
  if(countdownIndex >= 0){
    current = countdownIndex;
  } else {
    // if no countdown, show intro
    const introIndex = slides.findIndex(s => s.classList.contains('intro'));
    current = introIndex >= 0 ? introIndex : 0;
  }
  updateSlides();
})();
</script>
</body>
</html>
